"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PostgrestBuilder = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
class PostgrestBuilder {
    constructor(builder) {
        Object.assign(this, builder);
    }
    then(onfulfilled, onrejected) {
        // https://postgrest.org/en/stable/api.html#switching-schemas
        if (typeof this.schema === 'undefined') {
            // skip
        }
        else if (['GET', 'HEAD'].includes(this.method)) {
            this.headers['Accept-Profile'] = this.schema;
        }
        else {
            this.headers['Content-Profile'] = this.schema;
        }
        if (this.method !== 'GET' && this.method !== 'HEAD') {
            this.headers['Content-Type'] = 'application/json';
        }
        return cross_fetch_1.default(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
        })
            .then((res) => __awaiter(this, void 0, void 0, function* () {
            let error, data;
            if (res.ok) {
                error = null;
                data = yield res.json();
            }
            else {
                error = yield res.json();
                data = null;
            }
            const postgrestResponse = {
                error,
                data,
                status: res.status,
                statusText: res.statusText,
                body: data,
            };
            return postgrestResponse;
        }))
            .then(onfulfilled, onrejected);
    }
}
exports.PostgrestBuilder = PostgrestBuilder;
//# sourceMappingURL=types.js.map