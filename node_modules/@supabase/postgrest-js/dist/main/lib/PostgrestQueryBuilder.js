"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const PostgrestFilterBuilder_1 = __importDefault(require("./PostgrestFilterBuilder"));
/**
 * CRUD
 */
class PostgrestQueryBuilder extends types_1.PostgrestBuilder {
    constructor(url, { headers = {}, schema } = {}) {
        super({});
        this.url = new URL(url);
        this.headers = Object.assign({}, headers);
        this.schema = schema;
    }
    /**
     * Performs horizontal filtering with SELECT.
     *
     * @param columns  The columns to retrieve, separated by commas.
     */
    select(columns = '*') {
        this.method = 'GET';
        // Remove whitespaces except when quoted
        let quoted = false;
        const cleanedColumns = columns
            .split('')
            .map((c) => {
            if (/\s/.test(c) && !quoted) {
                return '';
            }
            if (c === '"') {
                quoted = !quoted;
            }
            return c;
        })
            .join('');
        this.url.searchParams.set('select', cleanedColumns);
        return new PostgrestFilterBuilder_1.default(this);
    }
    /**
     * Performs an INSERT into the table.
     *
     * @param values  The values to insert.
     * @param upsert  If `true`, performs an UPSERT.
     * @param onConflict By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.
     */
    insert(values, { upsert = false, onConflict } = {}) {
        this.method = 'POST';
        this.headers['Prefer'] = upsert
            ? 'return=representation,resolution=merge-duplicates'
            : 'return=representation';
        if (upsert && onConflict !== undefined)
            this.url.searchParams.set('on_conflict', onConflict);
        this.body = values;
        return new PostgrestFilterBuilder_1.default(this);
    }
    /**
     * Performs an UPDATE on the table.
     *
     * @param values  The values to update.
     */
    update(values) {
        this.method = 'PATCH';
        this.headers['Prefer'] = 'return=representation';
        this.body = values;
        return new PostgrestFilterBuilder_1.default(this);
    }
    /**
     * Performs a DELETE on the table.
     */
    delete() {
        this.method = 'DELETE';
        this.headers['Prefer'] = 'return=representation';
        return new PostgrestFilterBuilder_1.default(this);
    }
    /** @internal */
    rpc(params) {
        this.method = 'POST';
        this.body = params;
        return this;
    }
}
exports.default = PostgrestQueryBuilder;
//# sourceMappingURL=PostgrestQueryBuilder.js.map