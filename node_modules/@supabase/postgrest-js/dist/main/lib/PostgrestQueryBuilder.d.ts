import { PostgrestBuilder } from './types';
import PostgrestFilterBuilder from './PostgrestFilterBuilder';
/**
 * CRUD
 */
export default class PostgrestQueryBuilder<T> extends PostgrestBuilder<T> {
    constructor(url: string, { headers, schema }?: {
        headers?: {
            [key: string]: string;
        };
        schema?: string;
    });
    /**
     * Performs horizontal filtering with SELECT.
     *
     * @param columns  The columns to retrieve, separated by commas.
     */
    select(columns?: string): PostgrestFilterBuilder<T>;
    /**
     * Performs an INSERT into the table.
     *
     * @param values  The values to insert.
     * @param upsert  If `true`, performs an UPSERT.
     * @param onConflict By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.
     */
    insert(values: Partial<T> | Partial<T>[], { upsert, onConflict }?: {
        upsert?: boolean;
        onConflict?: string;
    }): PostgrestFilterBuilder<T>;
    /**
     * Performs an UPDATE on the table.
     *
     * @param values  The values to update.
     */
    update(values: Partial<T>): PostgrestFilterBuilder<T>;
    /**
     * Performs a DELETE on the table.
     */
    delete(): PostgrestFilterBuilder<T>;
}
//# sourceMappingURL=PostgrestQueryBuilder.d.ts.map